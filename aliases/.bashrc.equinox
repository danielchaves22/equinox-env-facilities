#!/bin/bash

#SCRIPT_PATH carregada no arquivo .bashrc, que invoca este
ENV_FILE=$SCRIPT_PATH/.env.equinox


if test -f $ENV_FILE; then
    source $ENV_FILE
    echo "[OK] Variáveis do arquivo '$ENV_FILE' carregadas com sucesso."
else
    echo "======================================================================================================================="
    echo "  ARQUIVO '$ENV_FILE' NÃO ENCONTRADO. NÃO SERÁ POSSÍVEL UTILIZAR OS ALIAS CRIADOS NO ARQUIVO '.bashrc.equinox'"
    echo "========================================================================================================================"
fi

alias flbr='flutterBuildAndRun'
alias flr='flutterRun'
alias cleanNpm='cleanNpm'
alias cwdir="cd $COMEXDEZ_WEB_PATH"
alias push='pushRemotes'
alias sshc='ssh -i comexdez_pvt_openssh restapi@tec.comexdez.com.br'
alias sshcp='scp $1 restapi@tec.comexdez.com.br'
alias ns='netStat'
alias cprb="npmRunDev $CATALOGO_PRODUTOS_PATH/backend"
alias cprf="npmRunDev $CATALOGO_PRODUTOS_PATH/frontend"
alias cprall='cprb && cprf'
alias stb='kill_port 3000'
alias stf='kill_port 3001'
alias kill='pKill'
alias stall='stb && stf'
alias nsall='ns 3000 && ns 3001'
alias pidall='showPid 3000 && showPid 3001'
alias pdfdir="cd $PDF_EXTRACTOR_PATH"
alias cppull="pullDir $CATALOGO_PRODUTOS_PATH"
alias pdfpull="pullDir $PDF_EXTRACTOR_PATH"
alias cpdir="cd $CATALOGO_PRODUTOS_PATH"
alias cpdcub="dockerComposeUpBuild $CATALOGO_PRODUTOS_PATH"
alias por='git pull origin $1'
alias pull='por $1'
alias prcg='rm -f -r node_modules/.prisma && npx prisma generate'
alias ch='git checkout $1'
alias dados='levantamentoDados'
alias efdir="cd $EQUINOX_ENV_FACILITIES_PATH"
alias list="ls"
alias cpr="bashCommand cprb && bashCommand cprf"
alias cptest="testBranchCp"

alias zdir="cd $ZENIT_PATH"
alias zdbf='docker build --build-arg NEXT_PUBLIC_API_URL="http://localhost:3000/api" -t zenit-frontend .'
alias zdrf='docker run --name zenit-frontend -p 3000:3000 zenit-frontend'
alias zr="bashCommand zrb && bashCommand zrf"
alias ztest="testBranchZ"
alias zdcub="dockerComposeUpBuild $ZENIT_PATH"
alias zrb="npmRunDev $ZENIT_PATH/backend"
alias zrf="npmRunDev $ZENIT_PATH/frontend"
alias zrall='zrb && zrf'
alias zpull="pullDir $ZENIT_PATH"

alias zcdir="cd $ZENIT_CALC_PATH"
alias zcdbf='docker build --build-arg NEXT_PUBLIC_API_URL="http://localhost:3000/api" -t zenit-frontend .'
alias zcdrf='docker run --name zenit-frontend -p 3000:3000 zenit-frontend'
alias zcr="bashCommand zcrb && bashCommand zcrf"
alias zctest="testBranchZC"
alias zcdcub="dockerComposeUpBuild $ZENIT_CALC_PATH"
alias zcrb="npmRunDev $ZENIT_CALC_PATH/backend"
alias zcrf="npmRunDev $ZENIT_CALC_PATH/frontend"
alias zcrall='zcrb && zcrf'
alias zcpull="pullDir $ZENIT_CALC_PATH"

alias utb="updateTestBranch"
alias ia="gh copilot suggest"

pullDir() {
    if [ -z "$1" ]; then
        echo "Uso: pullDir DIRETÓRIO"
        return 1
    fi
    
    echo "Entrando no diretório $1..."
    cd "$1" || { echo "Erro ao entrar no diretório $1"; return 1; }
    
    echo "Fazendo pull do repositório Git..."
    git pull
    
    echo "Voltando ao diretório anterior..."
    cd - || { echo "Erro ao voltar ao diretório anterior"; return 1; }
}

flutterBuildAndRun() {
    flutter clean
    flutter pub get
    flutter pub run build_runner build --delete-conflicting-outputs
    flutter run
}

flutterRun() {
    flutter pub get
    flutter run
}

pushRemote() {
    local remote_name=$1

    if git remote | grep -q "^${remote_name}$"; then
        
        # Se a branch foi especificada, usa ela, senão usa a branch atual
        if [ -n "$branch_name" ]; then
            git push "$remote_name" "$branch_name"
        else
            git push "$remote_name"
        fi
    else
        echo "Erro: Remote '${remote_name}' não existe"
        echo "Remotes disponíveis:"
        git remote -v
        return 1
    fi
}


pushRemotes() {
   echo "***********  ORIGIN ***********"
   pushRemote origin

    echo ""
    echo ""

    echo "***********  BITBUCKET ***********"
    pushRemote bitbucket

    echo ""
    echo ""

    echo "***********  GITHUB ***********"
    pushRemote github
}

netStat() {
    netstat -ano | findstr  0.0.0.0:$1
}

pKill() {
    taskkill //PID $1 //F
}

npmRunDev() {
    current_dir=$(pwd)
    cd $1
    npm run dev
    cd $current_dir
}

showPid() {
    if [ -z "$1" ]; then
        echo "Uso: kill_port PORTA"
        return 1
    fi

    echo "Procurando processos na porta $1..."
    local results=$(netstat -ano | findstr "0.0.0.0:$1")

    if [ -n "$results" ]; then
        echo "$results"
        echo ""

        # Extrair todos os PIDs únicos
        local pids=$(echo "$results" | awk '{print $5}' | sort -u)

        echo "$pids"
    else
        echo "Nenhum processo encontrado na porta $1"
    fi
}

kill_port() {
    if [ -z "$1" ]; then
        echo "Uso: kill_port PORTA"
        return 1
    fi

    echo "Procurando processos na porta $1..."
    local results=$(netstat -ano | findstr "0.0.0.0:$1")
    
    if [ -n "$results" ]; then
        echo "$results"
        echo ""

        # Extrair todos os PIDs únicos
        local pids=$(echo "$results" | awk '{print $5}' | sort -u)

        for pid in $pids; do
            if [ -n "$pid" ] && [ "$pid" -gt 0 ] 2>/dev/null; then
                echo "Matando processo PID: $pid"
                pKill $pid
            fi
        done

        echo ""
        echo "Verificando se a porta $1 ainda está em uso..."
        local check=$(netstat -ano | findstr ":$1")
        if [ -z "$check" ]; then
            echo "✓ Porta $1 liberada com sucesso!"
        else
            echo "⚠ Ainda há processos na porta $1:"
            echo "$check"
        fi
    else
        echo "Nenhum processo encontrado na porta $1"
    fi
}

dockerComposeUpBuild() {
    current_dir=$(pwd)
    cd $1
    echo "Iniciando o Docker Compose e construindo as imagens..."
    docker compose up --build -d
    cd $current_dir
}

levantamentoDados() {
    echo "Iniciando levantamento de dados..."
    current_dir=$(pwd)
    cd /c/dev/equinox/pdf-extractor
    python pdf_to_excel_updater.py
    echo "Levantamento de dados concluído."
    cd $current_dir
}

bashCommand() {
    local comando="$1"
    local titulo="${2:-Nova Instância Git Bash}"
    
    # Abrir janela vazia primeiro
    cmd.exe //c start "$titulo" "C:\Program Files\Git\bin\bash.exe"

    # Aguardar janela abrir e depois enviar comandos
    sleep 1

    # PowerShell para enviar comandos via SendKeys
    powershell.exe -Command "
        Add-Type -AssemblyName System.Windows.Forms;
        [System.Windows.Forms.SendKeys]::SendWait('$comando{ENTER}');
    "

    echo "✅ Comando '$comando' enviado para nova janela"
}

testBranchCp() {
    cpdir
    cd backend
    prcg
    cd ../
    utb $1
    cpr
}

testBranchZ() {
    zdir
    cd backend
    prcg
    cd ../
    utb $1
    zr
}

testBranchZC() {
    zcdir
    cd backend
    prcg
    cd ../
    utb $1
    zcr
}

updateTestBranch() {
    if [ -z "$1" ]; then
        echo "Informe o branch a ser testado"
        return 1
    fi

    git switch master 
    git pull 
    git switch $1
    git pull origin $1
}